#include <vector>
#include "Animals.h"
using namespace std;

int main() 
{
	// В методе1 базового класса вызывается метод2, который определен в этом же классе как невиртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
	// Класс потомок возвращает в методе1 вывод метода2 класса предка, а не потомка.
	{
		Animal animal;
		Cat cat;
		cout << cat.doVoice() << endl;
	}
	cout << "\n\n\n";
	// В методе1 базового класса вызывается метод2, который определен в этом же классе как виртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
	// В данном случае класс потомок возвращает в методе1 вывод метода уже класса потомка.
	{
		AnimalCorrect animal;
		CatCorrect cat;
		cout << cat.doVoice() << endl;
	}
	cout << "\n\n\n";
	// В базовом классе объявить метод невиртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?
	// В первом случае, вызовется метод класса предка, что по сути своей полиморфизма в себе никакого не несёт, во втором случае вызовется уже переопределенный в классе-потомке метод, что верно.
	{
		Animal *animal = new Cat;
		Cat* cat = new Cat;

		cout << animal->doSomething() << endl;
		cout << cat->doSomething() << endl;
		delete animal;
		delete cat;
	}
	cout << "\n\n\n";
	// В базовом классе объявить метод виртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?
	// Здесь в обоих случаях уже вызовется метод класса потомка.
	{
		AnimalCorrect* animal = new CatCorrect();
		CatCorrect* cat = new CatCorrect;

		cout << animal->doSomething() << endl;
		cout << cat->doSomething() << endl;
		delete animal;
		delete cat;
	}

	return 0;
}
